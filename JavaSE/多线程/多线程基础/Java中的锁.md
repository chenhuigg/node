### 乐观锁与悲观锁

---

**乐观锁**

乐观锁与悲观锁并不是指具体什么类型的锁，而是指看待问题的角度。

乐观锁认为，每次取数据时，别人都不会修改，所以不会上锁，但是在更新期间会判断别人是否更新该数据。

<br>

**乐观锁的实现CAS**

CAS（Compare And Swap/Set）

CAS是一种更新的原子操作，每次操作，都会增加版本号，操作结束后，比较版本号，如果版本号相同，就更新，否则就失败。

<br>

**悲观锁**

悲观锁认为，每次取数据时，别人都会修改，所以每次拿数据的时候都会上锁，别人想拿数据就会阻塞直到拿到锁。

<br>

**悲观锁的实现**

java中的悲观锁就是Synchronized

<br><br>

### 自旋锁

---

自旋锁指的是获取锁的线程不会立即阻塞，而是会以循环的方式不断获取锁。

因为自旋的消耗小于线程阻塞挂起再唤醒的消耗，但是自旋会消耗CPU，让CPU做无用功。

<br><br>

### Synchronized同步锁

---

**作用范围**

作用于方法时，锁住的是对象的实例（this）。

作用于静态方法时，锁住的是Class的实例，会锁住所有调用该类的线程。

<br><br>

### 可重入锁（递归锁）

---

同一线程，外层函数获得锁后，内层函数也获得锁。

```java
synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}
synchronized void setB() throws Exception{
    Thread.sleep(1000);
}
```

以上就是可重入锁，如果不是可重入锁，那么setB（）可能被其他线程占用，可能造成死锁。

<br><br>

### 公平锁和非公平锁

---

**公平锁**

加锁前查看是否有排列等待的线程，先来先得。

<br>

**非公平锁**

加锁时不考虑排列等待问题，直接尝试获取锁，获取不到直接到队尾等待。

非公平锁的性能比公平锁要高。

<br><br>

### 独占锁和共享锁

---

**独占锁**

指该锁一次只能被一个线程所持有。对ReentrantLock和Synchronized而言都是独占锁

<br>

**共享锁**

指该锁可以被多个线程所持有

对于ReentrantReadWriteLock，其读锁是共享锁，其写锁是独占锁。

读锁的共享锁可以保证并发读是非常高效的，读写，写读，写写的过程是互斥的。